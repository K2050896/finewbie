# Stochastic Programming using solvers.qp from Python and a linear utility function
from cvxopt import matrix, solvers
import numpy as np

def stochastic_programming(nA, nS, Y, nP, lamb, D, Returns, ic, goal, eff_fees,init_alloc):
	# Recall:
	# minimize     x'Px + q'x
	# subject to   Gx <= h
	#              Ax == b
	#
	# Input:  nA            - # of assets
	#         nS            - # of scenarios generated by GBM
 	#         Y             - original length of the goal
	#         nP            - # of periods remaining           (user input)
 	#         lamb          - risk aversion factor             (user input)
   	#                       - Greater value means more risk averse
	#         D             - allowable disposable income      (user input)
 	#         Returns       - total return matrix of all assets and scenarios
 	#         ic            - initial contribution             (user input)
	#         goal          - financial target                 (user input)
 	#         eff_fees      - mgmt fees of each asset
	# Output: sol - cvxopt solution object
     
    # Number of decision variables
    nd = nA * nS * nP + nA + nS * (nP-1)
    
    # Sample variance of wealths
    P_ = np.zeros((nA*nS,nS))
    for s in range(0,nS):
        for a in range(0,nA):
            P_[s*nA + a,s] = 1
    P_ = P_ - 1/nS
    P_ = np.concatenate((P_,np.zeros((P_.shape[0],nd-P_.shape[1]))),axis=1)
    P_ = np.concatenate((np.zeros((nd-P_.shape[0],nd)),P_))
    P = lamb * 1/nS * np.matrix(matrix(P_)*matrix(P_.T))
    
    # Define vector q
    q = -(1 - lamb) * np.ones((nA*nS,1))
    q = np.concatenate((np.zeros((nd-nA*nS,1)),q)) / nS

    ### Define matrix A ###
    if nP > 1: # If the tree is larger than one-period in size
        A = np.zeros(((nS * (nP-1) + 1, nd - nA*nS)))
        # define row 1 of A (t = 0 constraint)
        for x in range(0,nA):
            A[0,x] = 1
        # define t = 1 contraints
        for s in range(1,nS+1):
            ctr = -nA
            for w in range(0,3):                # 3 b/c R, p, X
                ctr = ctr + nA
                for y in range(0,nA):
                    if ctr == 0:
                        A[s,y + ctr] = Returns[y+(s-1)*nA,0]
                    if ctr == nA:
                        A[s,y + ctr + (s-1)*(nA + 1)] = 1 - 0    # 0 to be replaced by transaction costs
                        break
                    if ctr == 2*nA:
                        A[s,y + ctr + (s-1)*(nA + 1) - (nA-1)] = -1
        # define t = 2 ... t = T-1 constraints
        start_row = nS + 1
        ctr = 0
        ctr2 = -nS
        for t in range(2,nP):                   # t=2 to T-1
            ctr2 = ctr2 + nS
            for s in range(0,nS):               # s=1 to s=S
                ctr = ctr + (nA + 1)
                for d in range(0,nA):
                    A[start_row + ctr2 + s,ctr + d] = Returns[d + s*nA,t-1]
                for k in range(0,nA+1):
                    if k == 0:
                        A[start_row + ctr2 + s,ctr + nA + (nS-1)*(nA+1) + k] = 1 - 0
                    else:
                        A[start_row + ctr2 + s,ctr + nA + (nS-1)*(nA+1) + k] = -1
    
        # define t = T constraints
        A__ = np.zeros((nA*nS,nd-nA*nS))
        ncols = nd - nA*nS
        start_col = ncols - nA - (nS - 1)*(nA + 1)
        ctr = -(nA + 1)
        for s in range(0,nS):
            ctr = ctr + (nA + 1)                    # nA + 1 b/c p + X's
            for j in range(0,nA):
                A__[s*nA + j, start_col + j + ctr] = Returns[j + s*nA,-1]
    
        temp = -np.eye(nA*nS)
        temp = np.concatenate((np.zeros((A.shape[0],nA*nS)),temp))
    
        A = np.concatenate((A,A__))
        A = np.concatenate((A,temp),axis=1)
    else: # This means the tree is one-period in size
        A1 = np.concatenate((np.ones((1,nA)),np.zeros((1,nA*nS))),axis=1)
        
        A2 = np.eye(nA)
        for s in range(0,nS-1):
            A2 = np.concatenate((A2,np.eye(nA)))
        for s in range(0,nS):
            for j in range(0,nA):
                A2[j + s*nA,j] = Returns[j + s*nA,-1]
        
        A3 = -np.eye((nA*nS))
    
        A = np.concatenate((A2,A3),axis=1)
        A = np.concatenate((A1,A))
        
    # Define vector b
    b = np.zeros((nS * (nP-1) + nA*nS + 1,1))
    b[0] = ic                 # the first parameter is ALWAYS user's init. con.

    # Define matrix G
    G = -np.eye(nd)           # All variables non-negative
    
    # Each p is less than or equal to D (disposable income)
    G_ = np.zeros((nS*(nP-1),nd))
    for i in range(0,G_.shape[0]):
        start_col = (nA + 1)*i + nA
        G_[i, start_col] = 1

    # Sum of each scenario's terminal wealth is >= goal
    G__ = np.zeros((nS,nA*nS))
    ctr = -nA
    for s in range(1,nS+1):
        ctr = ctr + nA
        for a in range(1,nA+1):
            G__[-s,-a - ctr] = -1 * (1 - eff_fees[a-1]) # Subtract mgmt fees
    G__ = np.concatenate((np.zeros((nS,nd-nA*nS)),G__),axis=1)

    G = np.concatenate((G,G_,G__))
    
    ### Define vector h
    # Restricting initial allocation from concentrating on one asset
    ini_alloc = np.matrix(init_alloc).T
    h = np.zeros((nd,1))
    for i in range(0,ini_alloc.shape[0]):
        h[i] = -ic * ini_alloc[i]

    h_ = D * np.ones((nS*(nP-1),1))
    h__ = goal * np.ones((nS,1))

    h = np.concatenate((h,h_,h__))
    
#    # Define vector q
#    q = -(1 - lamb) * np.ones((nA*nS,1))
#    q_ = np.matrix(np.sum(G_.T,axis=1)).T
#    q = np.concatenate((q_[0:-(nA*nS)],q)) / nS

    # Solvers.qp need inputs to be in cvxopt.matrix format
    P = matrix(P)
    A = matrix(A)
    q = matrix(q)           # Do a transpose because q constructed above is already a transposed form
    b = matrix(b)
    G = matrix(G)
    h = matrix(h)
    
    # Extra outputs from the model to help compute mean and variance of terminal wealths
    Po = 1/nS * np.matrix(matrix(P_)*matrix(P_.T))
    qo = np.ones((nA*nS,1))
    qo = np.concatenate((np.zeros((nd-nA*nS,1)),qo)) / nS

    sol = solvers.qp(P, q, G, h, A, b)
    return sol, Po, qo
